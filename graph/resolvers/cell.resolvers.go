package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/vijaykramesh/gql-sheets/graph/common"
	"github.com/vijaykramesh/gql-sheets/graph/generated"
	"github.com/vijaykramesh/gql-sheets/graph/model"
)

// ID is the resolver for the id field.
func (r *cellResolver) ID(ctx context.Context, obj *model.Cell) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// Spreadsheet is the resolver for the spreadsheet field.
func (r *cellResolver) Spreadsheet(ctx context.Context, obj *model.Cell) (*model.Spreadsheet, error) {
	context := common.GetContext(ctx)
	var spreadsheet model.Spreadsheet
	err := context.Database.Where("id = ?", obj.SpreadsheetID).First(&spreadsheet).Error
	if err != nil {
		return nil, fmt.Errorf("error getting spreadsheet: %v", err)
	}
	return &spreadsheet, nil
}

// CreateCell is the resolver for the createCell field.
func (r *mutationResolver) CreateCell(ctx context.Context, input model.NewCell) (*model.Cell, error) {
	context := common.GetContext(ctx)
	var spreadsheet model.Spreadsheet
	err := context.Database.Where("id = ?", input.SpreadsheetID).First(&spreadsheet).Error
	if err != nil {
		return nil, fmt.Errorf("error getting spreadsheet: %v", err)
	}
	err = model.ValidateRowAndColumnIndexes(spreadsheet, input.RowIndex, input.ColumnIndex)
	if err != nil {
		return nil, err
	}
	cell := &model.Cell{
		RawValue:      input.RawValue,
		RowIndex:      input.RowIndex,
		ColumnIndex:   input.ColumnIndex,
		SpreadsheetID: input.SpreadsheetID,
	}
	err = context.Database.Create(&cell).Error
	if err != nil {
		return nil, fmt.Errorf("error creating cell: %v", err)
	}
	return cell, nil
}

// UpdateCell is the resolver for the updateCell field.
func (r *mutationResolver) UpdateCell(ctx context.Context, id string, input model.UpdateCell) (*model.Cell, error) {
	context := common.GetContext(ctx)
	var cell model.Cell
	err := context.Database.Where("id = ?", id).First(&cell).Error
	if err != nil {
		return nil, fmt.Errorf("error getting cell: %v", err)
	}
	var spreadsheet model.Spreadsheet
	err = context.Database.Where("id = ?", cell.SpreadsheetID).First(&spreadsheet).Error
	if err != nil {
		return nil, fmt.Errorf("error getting spreadsheet: %v", err)
	}
	err = model.ValidateRowAndColumnIndexes(spreadsheet, cell.RowIndex, cell.ColumnIndex)
	if err != nil {
		return nil, err
	}

	cell.RawValue = input.RawValue
	// TODO: validate & run any formula & update dependent cells
	err = context.Database.Save(&cell).Error
	if err != nil {
		return nil, fmt.Errorf("error updating cell: %v", err)
	}
	return &cell, nil
}

// UpdateCellBySpreadsheetIDColumnAndRow is the resolver for the updateCellBySpreadsheetIdColumnAndRow field.
func (r *mutationResolver) UpdateCellBySpreadsheetIDColumnAndRow(ctx context.Context, spreadsheetID string, columnIndex int, rowIndex int, input model.UpdateCell) (*model.Cell, error) {
	context := common.GetContext(ctx)
	var cell model.Cell
	err := context.Database.Where("spreadsheet_id = ? AND column_index = ? AND row_index = ?", spreadsheetID, columnIndex, rowIndex).First(&cell).Error
	if err != nil {
		// create a cell if it doesn't exist
		cell = model.Cell{
			SpreadsheetID: spreadsheetID,
			ColumnIndex:   columnIndex,
			RowIndex:      rowIndex,
		}
	}
	// TODO do we need to validate column_index & row_index since they were used in the lookup?
	cell.RawValue = input.RawValue

	var otherCells []model.Cell
	err = context.Database.Where("spreadsheet_id = ? and id != ?", spreadsheetID, cell.ID).Find(&otherCells).Error
	if err != nil {
		return nil, fmt.Errorf("error getting cells: %v", err)
	}

	cell.ComputedValue, err = cell.ComputeValueFromRaw(otherCells)
	err = context.Database.Save(&cell).Error
	if err != nil {
		return nil, fmt.Errorf("error updating cell: %v", err)
	}
	otherCells = append(otherCells, cell)
	dependentCells, err := cell.FindDependentCells(otherCells)
	for _, dependentCell := range dependentCells {
		dependentCell.ComputedValue, err = dependentCell.ComputeValueFromRaw(otherCells)
		if err != nil {
			return nil, err
		}
		err = context.Database.Save(&dependentCell).Error
		if err != nil {
			return nil, fmt.Errorf("error updating cell: %v", err)
		}

		// todo change this to recurse and support infinite reference depth
		filteredOtherCells := []model.Cell{}
		for _, otherCell := range otherCells {
			if otherCell.ID != dependentCell.ID {
				filteredOtherCells = append(filteredOtherCells, otherCell)
			}
		}
		filteredOtherCells = append(filteredOtherCells, dependentCell)
		dependentCells, err = dependentCell.FindDependentCells(filteredOtherCells)
		for _, dependentCell := range dependentCells {
			dependentCell.ComputedValue, err = dependentCell.ComputeValueFromRaw(filteredOtherCells)
			if err != nil {
				return nil, err
			}
			err = context.Database.Save(&dependentCell).Error
		}

	}

	return &cell, nil
}

// Cells is the resolver for the cells field.
func (r *queryResolver) Cells(ctx context.Context) ([]*model.Cell, error) {
	context := common.GetContext(ctx)
	var cells []*model.Cell
	err := context.Database.Find(&cells).Error
	if err != nil {
		return nil, fmt.Errorf("error getting cells: %v", err)
	}
	return cells, nil
}

// GetCell is the resolver for the getCell field.
func (r *queryResolver) GetCell(ctx context.Context, id string) (*model.Cell, error) {
	context := common.GetContext(ctx)
	var cell model.Cell
	err := context.Database.Where("id = ?", id).First(&cell).Error
	if err != nil {
		return nil, fmt.Errorf("error getting cell: %v", err)
	}
	return &cell, nil
}

// GetCellsBySpreadsheetID is the resolver for the getCellsBySpreadsheetId field.
func (r *queryResolver) GetCellsBySpreadsheetID(ctx context.Context, spreadsheetID string) ([]*model.Cell, error) {
	context := common.GetContext(ctx)
	var cells []*model.Cell
	err := context.Database.Where("spreadsheet_id = ?", spreadsheetID).Find(&cells).Error
	if err != nil {
		return nil, fmt.Errorf("error getting cells: %v", err)
	}
	return cells, nil
}

// GetCellsBySpreadsheetID is the resolver for the getCellsBySpreadsheetId field.
func (r *subscriptionResolver) GetCellsBySpreadsheetID(ctx context.Context, spreadsheetID string) (<-chan []*model.Cell, error) {
	ch := make(chan []*model.Cell)
	go func() {
		for {
			time.Sleep(1 * time.Second)
			var cells []*model.Cell
			err := common.GetContext(ctx).Database.Where("spreadsheet_id = ?", spreadsheetID).Find(&cells).Error
			if err != nil {
				panic(fmt.Errorf("error getting cells: %v", err))
			}
			ch <- cells
		}
	}()
	return ch, nil
}

// Cell returns generated.CellResolver implementation.
func (r *Resolver) Cell() generated.CellResolver { return &cellResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type cellResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
