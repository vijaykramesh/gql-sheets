package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"fmt"
	"github.com/vijaykramesh/gql-sheets/graph/common"
	"github.com/vijaykramesh/gql-sheets/graph/generated"
	"github.com/vijaykramesh/gql-sheets/graph/model"
	"strconv"
	"time"
)

// CreateSpreadsheet is the resolver for the createSpreadsheet field.
func (r *mutationResolver) CreateSpreadsheet(ctx context.Context, input model.NewSpreadsheet) (*model.Spreadsheet, error) {
	context := common.GetContext(ctx)
	spreadsheet := &model.Spreadsheet{
		Name:        input.Name,
		RowCount:    input.RowCount,
		ColumnCount: input.ColumnCount,
	}
	err := context.Database.Create(&spreadsheet).Error
	if err != nil {
		return nil, fmt.Errorf("error creating spreadsheet: %v", err)
	}
	return spreadsheet, nil
}

// UpdateSpreadsheet is the resolver for the updateSpreadsheet field.
func (r *mutationResolver) UpdateSpreadsheet(ctx context.Context, id string, input model.UpdateSpreadsheet) (*model.Spreadsheet, error) {
	context := common.GetContext(ctx)
	var spreadsheet model.Spreadsheet
	err := context.Database.Where("id = ?", id).First(&spreadsheet).Error
	if err != nil {
		return nil, fmt.Errorf("error getting spreadsheet: %v", err)
	}
	if input.Name != nil {
		spreadsheet.Name = *input.Name
	}
	if input.RowCount != nil {
		spreadsheet.RowCount = *input.RowCount
	}
	if input.ColumnCount != nil {
		spreadsheet.ColumnCount = *input.ColumnCount
	}

	// TODO: delete any cells that are out of bounds

	err = context.Database.Save(&spreadsheet).Error
	if err != nil {
		return nil, fmt.Errorf("error updating spreadsheet: %v", err)
	}
	return &spreadsheet, nil
}

// RevertSpreadsheet is the resolver for the revertSpreadsheet field.
func (r *mutationResolver) RevertSpreadsheet(ctx context.Context, id string, version string) (*model.Spreadsheet, error) {
	context := common.GetContext(ctx)
	var spreadsheet model.Spreadsheet
	err := context.Database.Where("id = ?", id).First(&spreadsheet).Error
	if err != nil {
		return nil, fmt.Errorf("error getting spreadsheet: %v", err)
	}
	// delete all cells with version > version
	err = context.Database.Where("spreadsheet_id = ? AND version > ?", id, version).Delete(&model.Cell{}).Error
	if err != nil {
		return nil, fmt.Errorf("error deleting cells: %v", err)
	}
	// return
	return &spreadsheet, nil
}

// Spreadsheets is the resolver for the spreadsheets field.
func (r *queryResolver) Spreadsheets(ctx context.Context) ([]*model.Spreadsheet, error) {
	context := common.GetContext(ctx)
	var spreadsheets []*model.Spreadsheet
	err := context.Database.Find(&spreadsheets).Error
	if err != nil {
		return nil, fmt.Errorf("error getting spreadsheets: %v", err)
	}
	return spreadsheets, nil
}

// GetSpreadsheet is the resolver for the getSpreadsheet field.
func (r *queryResolver) GetSpreadsheet(ctx context.Context, id string) (*model.Spreadsheet, error) {
	context := common.GetContext(ctx)
	var spreadsheet model.Spreadsheet
	err := context.Database.Where("id = ?", id).First(&spreadsheet).Error
	if err != nil {
		return nil, fmt.Errorf("error getting spreadsheet: %v", err)
	}
	return &spreadsheet, nil
}

// GetVersions is the resolver for the getVersions field.
func (r *queryResolver) GetVersions(ctx context.Context, id string) ([]*model.Version, error) {
	context := common.GetContext(ctx)
	var cells []*model.Cell
	err := context.Database.Where("spreadsheet_id = ?", id).Find(&cells).Error
	if err != nil {
		return nil, fmt.Errorf("error getting cells: %v", err)
	}
	versions := buildLatestVersionSlice(cells)

	return versions, nil
}

// ID is the resolver for the id field.
func (r *spreadsheetResolver) ID(ctx context.Context, obj *model.Spreadsheet) (string, error) {
	// TODO: this might be dumb, we maybe should just read it off obj
	context := common.GetContext(ctx)
	var spreadsheet model.Spreadsheet
	err := context.Database.Where("id = ?", obj.ID).First(&spreadsheet).Error
	if err != nil {
		return "", fmt.Errorf("error getting spreadsheet: %v", err)
	}
	return strconv.FormatUint(uint64(spreadsheet.ID), 10), nil
}

// GetVersions is the resolver for the getVersions field.
func (r *subscriptionResolver) GetVersions(ctx context.Context, id string) (<-chan []*model.Version, error) {
	ch := make(chan []*model.Version)
	go func() {
		for {
			context := common.GetContext(ctx)
			time.Sleep(1 * time.Second)
			var cells []*model.Cell
			err := context.Database.Where("spreadsheet_id = ?", id).Find(&cells).Error
			if err != nil {
				panic(fmt.Errorf("error getting cells: %v", err))
			}
			versions := buildLatestVersionSlice(cells)
			ch <- versions
		}
	}()
	return ch, nil
}
func buildLatestVersionSlice(cells []*model.Cell) []*model.Version {
	seenVersions := make(map[uint64]bool)
	var versions []*model.Version
	for _, cell := range cells {
		if _, ok := seenVersions[cell.Version]; ok {
			continue
		}
		seenVersions[cell.Version] = true
		version := &model.Version{
			Version: strconv.FormatUint(cell.Version, 10),
		}
		versions = append(versions, version)
	}
	return versions
}

// Spreadsheet returns generated.SpreadsheetResolver implementation.
func (r *Resolver) Spreadsheet() generated.SpreadsheetResolver { return &spreadsheetResolver{r} }

type spreadsheetResolver struct{ *Resolver }
